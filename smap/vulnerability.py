import urllib.request
import urllib.error
import urllib.parse
import ssl
import http.cookiejar
import re
import base64
from typing import List, Dict, Optional, Tuple
from smap.utils import Colors

try:
    from bs4 import BeautifulSoup
except ImportError:
    BeautifulSoup = None

class VulnerabilityScanner:
    def __init__(self):
        self.vulnerability_db = self.load_vulnerability_signatures()

    def load_vulnerability_signatures(self) -> Dict:
        return {
            'weak_ssh': {
                'description': 'SSH service detected - potential for brute force attacks',
                'severity': 'medium',
                'recommendation': 'Use key-based authentication, disable root login'
            },
            'telnet_open': {
                'description': 'Telnet service is insecure and transmits data in plain text',
                'severity': 'high',
                'recommendation': 'Disable Telnet and use SSH instead'
            },
            'default_web_interface': {
                'description': 'Default web interface may have default credentials',
                'severity': 'high',
                'recommendation': 'Change default credentials and update firmware'
            },
            'snmp_community': {
                'description': 'SNMP service detected - may use default community strings',
                'severity': 'medium',
                'recommendation': 'Use SNMPv3 or disable SNMP if not needed'
            },
            'upnp_exposed': {
                'description': 'UPnP service exposed - potential for device manipulation',
                'severity': 'medium',
                'recommendation': 'Disable UPnP if not required'
            },
            'default_credentials': {
                'description': 'Service accepts default credentials',
                'severity': 'high',
                'recommendation': 'Change default credentials immediately'
            }
        }

    def scan_vulnerabilities(self, host_info: Dict, default_creds: Optional[Dict]) -> List[Dict]:
        vulns = []
        for port_info in host_info['ports']:
            port = port_info['port']
            service = port_info['service'].lower()
            proto = port_info.get('protocol', 'tcp')
            if proto == 'tcp':
                if port == 22:
                    vulns.append({**self.vulnerability_db['weak_ssh'], 'port': port, 'vulnerability': 'weak_ssh'})
                elif port == 23:
                    vulns.append({**self.vulnerability_db['telnet_open'], 'port': port, 'vulnerability': 'telnet_open'})
                elif port in [80, 8080, 443, 8443]:
                    vulns.append({**self.vulnerability_db['default_web_interface'], 'port': port, 'vulnerability': 'default_web_interface'})
                elif port == 161:
                    vulns.append({**self.vulnerability_db['snmp_community'], 'port': port, 'vulnerability': 'snmp_community'})
                elif port == 1900:
                    vulns.append({**self.vulnerability_db['upnp_exposed'], 'port': port, 'vulnerability': 'upnp_exposed'})
            elif proto == 'udp':
                if port == 161:
                    vulns.append({**self.vulnerability_db['snmp_community'], 'port': port, 'vulnerability': 'snmp_community'})
                elif port == 1900:
                    vulns.append({**self.vulnerability_db['upnp_exposed'], 'port': port, 'vulnerability': 'upnp_exposed'})
            if default_creds:
                svc_name = service.split()[0]
                if port in [80, 443, 8080, 8443, 9000]:
                    creds_list = default_creds.get('http', [])
                elif port == 21:
                    creds_list = default_creds.get('ftp', [])
                elif port == 22:
                    creds_list = default_creds.get('ssh', []) or default_creds.get('openssh', [])
                elif port in [23, 9999]:
                    creds_list = default_creds.get('telnet', [])
                else:
                    creds_list = []
                if creds_list:
                    if self.check_default_creds(host_info['ip'], port, creds_list):
                        vulns.append({
                            'port': port,
                            'vulnerability': 'default_credentials',
                            **self.vulnerability_db['default_credentials'],
                            'service': svc_name
                        })
        return vulns

    def check_default_creds(self, host: str, port: int, creds_list: List[Tuple[str,str]]) -> bool:
        try:
            if port in [80, 443, 8080, 8443, 9000]:
                return self.check_http_auth(host, port, creds_list)
            elif port == 21:
                return self.check_ftp_auth(host, port, creds_list)
            elif port == 22:
                return self.check_ssh_auth(host, port, creds_list)
            elif port in [23, 9999]:
                return self.check_telnet_auth(host, port, creds_list)
            else:
                return False
        except Exception:
            return False

    def check_http_auth(self, host: str, port: int, creds_list: List[Tuple[str,str]]) -> bool:
        if BeautifulSoup is None:
            print(f"{Colors.YELLOW}[WARNING]{Colors.RESET} BeautifulSoup not available. Falling back to basic auth check.")
            return self.check_http_basic_auth(host, port, creds_list)

        scheme = 'https' if port in [443, 8443] else 'http'
        base_url = f"{scheme}://{host}:{port}"
        login_paths = ['', '/login', '/admin', '/login.php', '/index.html', '/admin/login', '/start.ghtml']

        cj = http.cookiejar.CookieJar()
        opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE

        for path in login_paths:
            try:
                login_url = base_url + path
                req = urllib.request.Request(login_url)
                req.add_header('User-Agent', 'SMAP/1.0')
                if scheme == 'https':
                    resp = opener.open(req, timeout=5, context=context)
                else:
                    resp = opener.open(req, timeout=5)
                if resp.status not in [200, 301, 302]:
                    continue
                html = resp.read().decode('utf-8', errors='ignore')
                soup = BeautifulSoup(html, 'html.parser')
                forms = soup.find_all('form')
                if not forms:
                    continue
                form = forms[0]
                action = form.get('action') or path
                if action.startswith('/'):
                    full_action = base_url + action
                else:
                    full_action = login_url.rsplit('/', 1)[0] + '/' + action
                method = form.get('method', 'post').lower()
                inputs = form.find_all('input')
                user_field = None
                pass_field = None
                other_fields = {}
                for inp in inputs:
                    name = inp.get('name')
                    if not name:
                        continue
                    typ = inp.get('type', 'text').lower()
                    value = inp.get('value', '')
                    if typ == 'password' and pass_field is None:
                        pass_field = name
                    elif typ in ['text', 'email'] and user_field is None and any(keyword in name.lower() for keyword in ['user', 'name', 'login', 'email']):
                        user_field = name
                    if typ not in ['submit', 'button']:
                        other_fields[name] = value
                if user_field and pass_field:
                    for username, password in creds_list:
                        data = {user_field: username, pass_field: password, **other_fields}
                        data_enc = urllib.parse.urlencode(data).encode()
                        req = urllib.request.Request(full_action, data=data_enc if method == 'post' else None, method=method.upper())
                        req.add_header('User-Agent', 'SMAP/1.0')
                        if scheme == 'https':
                            login_resp = opener.open(req, timeout=5, context=context)
                        else:
                            login_resp = opener.open(req, timeout=5)
                        check_req = urllib.request.Request(base_url)
                        check_req.add_header('User-Agent', 'SMAP/1.0')
                        if scheme == 'https':
                            check_resp = opener.open(check_req, timeout=5, context=context)
                        else:
                            check_resp = opener.open(check_req, timeout=5)
                        check_html = check_resp.read().decode('utf-8', errors='ignore')
                        check_soup = BeautifulSoup(check_html, 'html.parser')
                        if not check_soup.find('form') or any(keyword in check_html.lower() for keyword in ['logout', 'dashboard', 'welcome']):
                            return True
                        if not re.search(r'login|sign in|incorrect', check_html, re.I):
                            return True
            except urllib.error.HTTPError as e:
                if e.code in [401, 403]:
                    break
            except Exception:
                pass
        return self.check_http_basic_auth(host, port, creds_list)

    def check_http_basic_auth(self, host: str, port: int, creds_list: List[Tuple[str,str]]) -> bool:
        scheme = 'https' if port in [443, 8443] else 'http'
        url = f"{scheme}://{host}:{port}/"
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        for username, password in creds_list:
            try:
                auth_str = f"{username}:{password}"
                b64_auth = base64.b64encode(auth_str.encode()).decode()
                req = urllib.request.Request(url)
                req.add_header('Authorization', f'Basic {b64_auth}')
                req.add_header('User-Agent', 'SMAP/1.0')
                if scheme == 'https':
                    with urllib.request.urlopen(req, timeout=5, context=context) as response:
                        if response.status == 200:
                            return True
                else:
                    with urllib.request.urlopen(req, timeout=5) as response:
                        if response.status == 200:
                            return True
            except urllib.error.HTTPError as e:
                if e.code in [401, 403]:
                    continue
                else:
                    continue
            except Exception:
                continue
        return False

    def check_ftp_auth(self, host: str, port: int, creds_list: List[Tuple[str,str]]) -> bool:
        import ftplib
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=5)
        except Exception:
            return False
        for username, password in creds_list:
            try:
                ftp.login(user=username, passwd=password)
                ftp.quit()
                return True
            except Exception:
                continue
        try:
            ftp.quit()
        except Exception:
            pass
        return False

    def check_ssh_auth(self, host: str, port: int, creds_list: List[Tuple[str,str]]) -> bool:
        try:
            import paramiko
        except ImportError:
            return False
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        for username, password in creds_list:
            try:
                client.connect(host, port=port, username=username, password=password, timeout=5, allow_agent=False, look_for_keys=False)
                client.close()
                return True
            except Exception:
                continue
        return False

    def check_telnet_auth(self, host: str, port: int, creds_list: List[Tuple[str,str]]) -> bool:
        try:
            import telnetlib
        except ImportError:
            return False
        for username, password in creds_list:
            try:
                tn = telnetlib.Telnet(host, port, timeout=5)
                tn.read_until(b"login: ", timeout=5)
                tn.write(username.encode('ascii') + b"\n")
                tn.read_until(b"Password: ", timeout=5)
                tn.write(password.encode('ascii') + b"\n")
                idx, _, _ = tn.expect([b"Login incorrect", b"$", b">", b"#", b"%"], timeout=5)
                tn.close()
                if idx in [1, 2, 3, 4]:
                    return True
            except Exception:
                continue
        return False



